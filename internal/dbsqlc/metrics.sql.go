// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: metrics.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkInsertMetrics = `-- name: BulkInsertMetrics :many
WITH input_data AS (
    SELECT
        UNNEST($1::TIMESTAMPTZ[]) AS created_at,
        UNNEST($2::UUID[]) AS tenant_id,
        UNNEST($3::UUID[]) AS resource_id,
        UNNEST(CAST($4::text[] AS metric_event_type[])) AS event_type,
        UNNEST($5::JSONB[]) AS data
)
INSERT INTO metric_events (created_at, tenant_id, resource_id, event_type, data)
SELECT
    input_data.created_at,
    input_data.tenant_id,
    input_data.resource_id,
    input_data.event_type,
    input_data.data
FROM input_data
RETURNING id, created_at, tenant_id, resource_id, event_type, data
`

type BulkInsertMetricsParams struct {
	CreatedAts  []pgtype.Timestamptz `json:"created_ats"`
	TenantIds   []pgtype.UUID        `json:"tenant_ids"`
	ResourceIds []pgtype.UUID        `json:"resource_ids"`
	EventTypes  []string             `json:"event_types"`
	Datas       [][]byte             `json:"datas"`
}

func (q *Queries) BulkInsertMetrics(ctx context.Context, db DBTX, arg BulkInsertMetricsParams) ([]*MetricEvent, error) {
	rows, err := db.Query(ctx, bulkInsertMetrics,
		arg.CreatedAts,
		arg.TenantIds,
		arg.ResourceIds,
		arg.EventTypes,
		arg.Datas,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*MetricEvent
	for rows.Next() {
		var i MetricEvent
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.TenantID,
			&i.ResourceID,
			&i.EventType,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetrics = `-- name: GetMetrics :many
SELECT
    time_bucket(COALESCE($1::interval, '1 minute'), minute) as bucket,
    SUM(succeeded_count)::int as succeeded_count,
    SUM(failed_count)::int as failed_count
FROM
    metric_events_summary
WHERE
    tenant_id = $2::uuid AND
    resource_id = $3::uuid AND
    -- timestamptz makes this fast, apparently: 
    -- https://www.timescale.com/forum/t/very-slow-query-planning-time-in-postgresql/255/8
    minute > $4::timestamptz AND
    minute < $5::timestamptz
GROUP BY bucket
ORDER BY bucket
`

type GetMetricsParams struct {
	Interval      pgtype.Interval    `json:"interval"`
	Tenantid      pgtype.UUID        `json:"tenantid"`
	Resourceid    pgtype.UUID        `json:"resourceid"`
	Createdafter  pgtype.Timestamptz `json:"createdafter"`
	Createdbefore pgtype.Timestamptz `json:"createdbefore"`
}

type GetMetricsRow struct {
	Bucket         interface{} `json:"bucket"`
	SucceededCount int32       `json:"succeeded_count"`
	FailedCount    int32       `json:"failed_count"`
}

func (q *Queries) GetMetrics(ctx context.Context, db DBTX, arg GetMetricsParams) ([]*GetMetricsRow, error) {
	rows, err := db.Query(ctx, getMetrics,
		arg.Interval,
		arg.Tenantid,
		arg.Resourceid,
		arg.Createdafter,
		arg.Createdbefore,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMetricsRow
	for rows.Next() {
		var i GetMetricsRow
		if err := rows.Scan(&i.Bucket, &i.SucceededCount, &i.FailedCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMetrics = `-- name: InsertMetrics :one
INSERT INTO metric_events (created_at, tenant_id, resource_id, event_type, data)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, created_at, tenant_id, resource_id, event_type, data
`

type InsertMetricsParams struct {
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	TenantID   pgtype.UUID        `json:"tenant_id"`
	ResourceID pgtype.UUID        `json:"resource_id"`
	EventType  MetricEventType    `json:"event_type"`
	Data       []byte             `json:"data"`
}

func (q *Queries) InsertMetrics(ctx context.Context, db DBTX, arg InsertMetricsParams) (*MetricEvent, error) {
	row := db.QueryRow(ctx, insertMetrics,
		arg.CreatedAt,
		arg.TenantID,
		arg.ResourceID,
		arg.EventType,
		arg.Data,
	)
	var i MetricEvent
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.TenantID,
		&i.ResourceID,
		&i.EventType,
		&i.Data,
	)
	return &i, err
}
